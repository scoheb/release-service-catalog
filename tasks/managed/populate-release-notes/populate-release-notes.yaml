---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: populate-release-notes
  labels:
    app.kubernetes.io/version: "4.0.0"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: >-
    Tekton task to populate releaseNotes keys in the data.json file
  params:
    - name: dataPath
      description: Path to the JSON string of the merged data to use
      type: string
    - name: snapshotPath
      description: Path to the JSON string of the mapped Snapshot spec in the data workspace
      type: string
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored.
      type: string
      default: "empty"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire.
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable.
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: sourceDataArtifact
      type: string
      description: Location of trusted artifacts to be used to populate data directory
      default: ""
    - name: subdirectory
      description: Subdirectory inside the workspace to be used
      type: string
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: $(workspaces.data.path)
    - name: stepActionGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog stepActions to be used are stored
      default: https://github.com/konflux-ci/release-service-catalog.git
    - name: stepActionGitRevision
      type: string
      description: The revision in the stepActionGitUrl repo to be used
      default: production
  results:
    - name: sbomDataPath
      description: Path to data used in the component SBOM creation in the data workspace
    - description: Produced trusted data artifact
      name: sourceDataArtifact
      type: string
  workspaces:
    - name: data
      description: The workspace where the data JSON file resides
  volumes:
    - name: workdir
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
      - name: "HOME"
        value: "/tekton/home"
  steps:
    - name: skip-trusted-artifact-operations
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.stepActionGitUrl)
          - name: revision
            value: $(params.stepActionGitRevision)
          - name: pathInRepo
            value: stepactions/skip-trusted-artifact-operations/skip-trusted-artifact-operations.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: subdirectory
          value: $(params.subdirectory)
        - name: dataDir
          value: $(params.dataDir)
    - name: use-trusted-artifact
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.stepActionGitUrl)
          - name: revision
            value: $(params.stepActionGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: dataDir
          value: $(params.dataDir)
        - name: subdirectory
          value: $(params.subdirectory)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: populate-release-notes-images
      image: quay.io/konflux-ci/release-service-utils:e85ceb962ee6f4d0672b4aa4e9946621ab302f20
      script: |
        #!/usr/bin/env bash
        set -ex

        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No data JSON was provided."
            exit 1
        fi

        SNAPSHOT_FILE="$(params.dataDir)/$(params.snapshotPath)"
        if [ ! -f "${SNAPSHOT_FILE}" ] ; then
            echo "No valid snapshot file was provided."
            exit 1
        fi

        UNIQUE_TAG_REGEX="(rhel-)?v?[0-9]+\.[0-9]+(\.[0-9]+)?-[0-9]{8,}"

        # Initialize the SBOM data result
        relativeDir=$(dirname "$(params.dataPath)")
        sbomDataPath="$(params.dataDir)/${relativeDir}/sbom_data.json"
        echo -n "${relativeDir}/sbom_data.json" > "$(results.sbomDataPath.path)"
        cp "${DATA_FILE}" "${sbomDataPath}"

        NUM_COMPONENTS=$(jq '.components | length' "${SNAPSHOT_FILE}")
        for ((i = 0; i < NUM_COMPONENTS; i++))
        do
            component=$(jq -c --argjson i "$i" '.components[$i]' "${SNAPSHOT_FILE}")
            name=$(jq -r '.name' <<< "$component")
            deliveryRepo=$(jq -er '."rh-registry-repo"' <<< "$component")
            tags=$(jq -c '.tags' <<< "$component")
            image=$(jq -r '.containerImage' <<< "$component")
            if ! [[ "$image" =~ ^[^:]+@sha256:[0-9a-f]+$ ]] ; then
                echo "Failed to extract sha256 tag from ${image}. Exiting with failure"
                exit 1
            fi
            sha=$(echo "${image}" | cut -d ':' -f 2)
            # containerImage should be of the form registry.redhat.io/foo/bar@sha256:abcde
            # This value will be used as the basis for the example values that follow
            containerImage="${deliveryRepo}@sha256:${sha}"
            # Construct CVE json
            CVEsJson='{"cves":{"fixed":{}}}'
            CVES=$(jq -c '[.releaseNotes.cves[]? | select(.component=="'"$name"'")]' "${DATA_FILE}")
            NUM_CVES=$(jq 'length' <<< "$CVES")
            for ((j = 0; j < NUM_CVES; j++)); do
                cve=$(jq -c --argjson j "$j" '.[$j]' <<< "$CVES")
                cveJson=$(jq -n \
                    --arg id "$(jq -r '.key' <<< "$cve")" \
                    --argjson packages "$(jq -c '.packages // []' <<< "$cve")" \
                    '{($id): {"packages": $packages}}')
                CVEsJson=$(jq --argjson cve "$cveJson" '.cves.fixed += $cve' <<< "$CVEsJson")
            done
            # Add one entry per arch (amd64 for example)
            get-image-architectures "${image}" | while IFS= read -r arch_json;
            do
                arch=$(jq -r .platform.architecture <<< "${arch_json}")
                digest=$(jq -r .digest <<< "${arch_json}")
                multiarch=$(jq -r .multiarch <<< "${arch_json}")
                containerImage="${deliveryRepo}@${digest}"
                # purl should be pkg:oci/bar@sha256%3Aabcde?arch=amd64&repository_url=registry.redhat.io/foo
                purl="pkg:oci/${deliveryRepo##*/}@${digest/:/%3A}?arch=${arch}&repository_url=${deliveryRepo%/*}"

                uniqueTag=""
                NUM_TAGS=$(jq length <<< "$tags")
                for ((j = 0; j < NUM_TAGS; j++)) ; do
                    tag=$(jq -r --argjson j "$j" '.[$j]' <<< "$tags")
                    if [[ $tag =~ $UNIQUE_TAG_REGEX ]] && [[ ${#tag} > ${#uniqueTag} ]] ; then
                        uniqueTag="${tag}"
                    fi
                done

                # if a unique tag is found, then purl will become:
                # pkg:oci/bar@sha256%3Aabcde?arch=amd64&repository_url=registry.redhat.io/foo&tag=0.1-12345678
                if [[ -n $uniqueTag ]] ; then
                    purl="${purl}&tag=${uniqueTag}"
                fi

                jsonString=$(jq -cn \
                    --arg component "$name" \
                    --arg arch "$arch" \
                    --arg containerImage "$containerImage" \
                    --arg purl "$purl" \
                    --arg repository "$deliveryRepo" \
                    --argjson tags "$tags" \
                    '{"architecture": $arch, "containerImage": $containerImage, "purl": $purl,
                    "repository": $repository, "tags": $tags, "component": $component}')
                if [ "$(jq '.cves.fixed | length' <<< "$CVEsJson")" -gt 0 ]; then
                    jsonString=$(jq --argjson cves "$CVEsJson" '. += $cves' <<< "$jsonString")
                fi

                # Inject JSON into data.json
                jq --argjson image "$jsonString" '.releaseNotes.content.images += [$image]' "${DATA_FILE}" > \
                    /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"

                # Inject SBOM-related data into an SBOM data file
                sbomJsonString=$(jq -cn \
                    --arg component "$name" \
                    --arg arch "$arch" \
                    --arg containerImage "$containerImage" \
                    --arg purl "$purl" \
                    --arg repository "$deliveryRepo" \
                    --arg multiarch "$multiarch" \
                    --arg imageSha "$sha" \
                    --argjson tags "$tags" \
                    '{"architecture": $arch, "containerImage": $containerImage, "purl": $purl,
                    "multiarch": $multiarch, "imageSha": $imageSha, "repository": $repository,
                    "tags": $tags, "component": $component}')

                jq --argjson image "$sbomJsonString" \
                    '.images = (.images // []) + [$image]' \
                    "${sbomDataPath}" > \
                    /tmp/sbomData.tmp && mv /tmp/sbomData.tmp "${sbomDataPath}"
            done
        done
    - name: populate-release-notes-type-and-references
      image: quay.io/konflux-ci/release-service-utils:e85ceb962ee6f4d0672b4aa4e9946621ab302f20
      script: |
        #!/usr/bin/env bash
        set -ex

        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No data JSON was provided."
            exit 1
        fi
        cat "$(params.dataDir)/$(params.dataPath)"

        NUM_CVES=$(jq '.releaseNotes.cves | length' "${DATA_FILE}")

        # Set type to RHSA if there are fixed CVEs
        if [[ "$NUM_CVES" -gt 0 ]] ; then
            jq '.releaseNotes.type = "RHSA"' "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
        fi

        if [ "$(jq -r '.releaseNotes.type' "${DATA_FILE}")" != "RHSA" ] ; then
            echo "Type is not RHSA. Ensuring references key exists, but not adding any"
            jq '.releaseNotes.references += []' "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
            cat "$(params.dataDir)/$(params.dataPath)"
            exit 0
        fi

        # Inject classification link into data.json references
        jq '.releaseNotes.references += ["https://access.redhat.com/security/updates/classification/"]' \
            "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"

        for ((i = 0; i < NUM_CVES; i++))
        do
            cve=$(jq -r --argjson i "$i" '.releaseNotes.cves[$i].key' "${DATA_FILE}")
            # Inject cve link into data.json references
            jq --arg cve "$cve" '.releaseNotes.references += ["https://access.redhat.com/security/cve/\($cve)"]' \
                "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
        done

        # Remove duplicate references
        jq '.releaseNotes.references |= unique' "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
        cat "$(params.dataDir)/$(params.dataPath)"
    - name: create-trusted-artifact
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.stepActionGitUrl)
          - name: revision
            value: $(params.stepActionGitRevision)
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: dataDir
          value: $(params.dataDir)
        - name: subdirectory
          value: $(params.subdirectory)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
    - name: patch-source-data-artifact-result
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.stepActionGitUrl)
          - name: revision
            value: $(params.stepActionGitRevision)
          - name: pathInRepo
            value: stepactions/patch-source-data-artifact-result/patch-source-data-artifact-result.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
