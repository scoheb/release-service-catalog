---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: populate-release-notes
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    Tekton task to populate fields of the releaseNotes key in the data.json
    file. It will update the data.json in place so that downstream tasks relying on
    the releaseNotes data can use it.
  params:
    - name: dataPath
      description: Path to the JSON string of the merged data to use
      type: string
    - name: snapshotPath
      description: Path to the JSON string of the mapped Snapshot spec in the data workspace
      type: string
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: sourceDataArtifact
      type: string
      description: Location of trusted artifacts to be used to populate data directory
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks and stepactions to be used are stored
    - name: taskGitRevision
      type: string
      description: The revision in the taskGitUrl repo to be used
    - name: binaries_dir
      description: The location of github release binaries. Needed for PURL generation
      type: string
      default: ""
    - name: github_release_version
      description: The version string of the release (from collect-gh-params)
      type: string
      default: ""
    - name: github_release_url
      description: The url of the release (from collect-gh-params)
      type: string
      default: ""
  results:
    - description: Produced trusted data artifact
      name: sourceDataArtifact
      type: string
  volumes:
    - name: workdir
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: validate-cve-issues-in-cves
      image: quay.io/konflux-ci/release-service-utils:ea7868ebdcc7a2116c620255034226611d837f42
      computeResources:
        limits:
          memory: 32Mi
        requests:
          memory: 32Mi
          cpu: 10m
      env:
        - name: ACCESS_TOKEN
          valueFrom:
            secretKeyRef:
              name: konflux-advisory-jira-secret
              key: token
      script: |
        #!/usr/bin/env bash
        set -x

        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No data JSON was provided."
            exit 1
        fi

        if ! jq -e '.releaseNotes.issues.fixed' "$DATA_FILE" > /dev/null; then
            echo "No issues.fixed found. Skipping CVE validation."
            exit 0
        fi

        declare -A RELEASE_CVES
        NUM_CVES=$(jq '.releaseNotes.cves | length' "${DATA_FILE}")
        for ((i = 0; i < NUM_CVES; i++)); do
            cve=$(jq -r --argjson i "$i" '.releaseNotes.cves[$i].key' "${DATA_FILE}")
            RELEASE_CVES["$cve"]=1
        done

        CVE_FIELD="customfield_12324749"
        RC=0

        NUM_ISSUES=$(jq -cr '.releaseNotes.issues.fixed | length' "${DATA_FILE}")
        for ((i = 0; i < NUM_ISSUES; i++)); do
            issue=$(jq -c --argjson i "$i" '.releaseNotes.issues.fixed[$i]' "${DATA_FILE}")
            server=$(jq -r '.source' <<< "$issue")
            issue_id=$(jq -r '.id' <<< "$issue")

            # Currently only handle issues.redhat.com
            if [ "$server" != "issues.redhat.com" ] ; then
                echo "Skipping non-JIRA issue: $issue_id from $server"
                continue
            fi

            API_URL="https://${server}/rest/api/2/issue/${issue_id}"

            set +x # Don't leak the ACCESS_TOKEN
            OUTPUT=$(curl-with-retry --retry 3 -H "Authorization: Bearer $ACCESS_TOKEN" "${API_URL}" 2>/dev/null)
            CURL_RC=$?
            set -x

            if [ "$CURL_RC" -ne 0 ] ; then
                echo "Warning: Could not fetch issue $issue_id from $server. Skipping CVE validation for this issue."
                continue
            fi

            # Check if this is a vulnerability issue
            ISSUE_TYPE=$(jq -r '.fields.issuetype.name' <<< "$OUTPUT")
            if [ "$ISSUE_TYPE" != "Vulnerability" ] ; then
                echo "Issue $issue_id is not a Vulnerability (type: $ISSUE_TYPE). Skipping."
                continue
            fi

            CVE_ID=$(jq -r --arg field "$CVE_FIELD" '.fields[$field]' <<< "$OUTPUT")

            if [ "$CVE_ID" == "null" ] || [ -z "$CVE_ID" ]; then
                echo "Warning: Issue $issue_id is a Vulnerability but has no CVE ID. Skipping."
                continue
            fi

            # Check if the CVE is present in releaseNotes.cves
            if [[ ! -v RELEASE_CVES[$CVE_ID] ]]; then
                echo "Error: Issue $issue lists 'CVE ID' $CVE_ID" \
                  "but that CVE is not present in the releaseNotes.cves section." | tee -a /tmp/errors.txt
                RC=1
            fi
        done

        if [ "$RC" -ne 0 ] ; then
            echo "Errors were found in the CVE validation:"
            cat /tmp/errors.txt
        fi
        exit $RC
    - name: populate-release-notes-images
      image: quay.io/konflux-ci/release-service-utils:ea7868ebdcc7a2116c620255034226611d837f42
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: '1'
      script: |
        #!/usr/bin/env bash
        set -ex

        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No data JSON was provided."
            exit 1
        fi

        # Try to extract the first contentType if it exists
        content_type=$(jq -r '.mapping.components[]?.contentGateway?.contentType // empty' "$DATA_FILE" | head -n1)

        # Extract github field from data.json
        github_field=$(jq -r '.github // empty' "$DATA_FILE")
        if [[ -n "$github_field" ]]; then
            echo "Github release. Skipping image-specific release note generation."
            exit 0
        fi

        if [ "$content_type" == "binary" ]; then
            echo "Content type is binary. Skipping image-specific release note generation."
            exit 0
        fi

        SNAPSHOT_FILE="$(params.dataDir)/$(params.snapshotPath)"
        if [ ! -f "${SNAPSHOT_FILE}" ] ; then
            echo "No valid snapshot file was provided."
            exit 1
        fi

        UNIQUE_TAG_REGEX="(rhel-)?v?[0-9]+\.[0-9]+(\.[0-9]+)?-[0-9]{8,}"

        NUM_COMPONENTS=$(jq '.components | length' "${SNAPSHOT_FILE}")
        for ((i = 0; i < NUM_COMPONENTS; i++))
        do
            component=$(jq -c --argjson i "$i" '.components[$i]' "${SNAPSHOT_FILE}")
            name=$(jq -r '.name' <<< "$component")
            deliveryRepo=$(jq -er '."rh-registry-repo"' <<< "$component")
            tags=$(jq -c '.tags' <<< "$component")
            image=$(jq -r '.containerImage' <<< "$component")
            if ! [[ "$image" =~ ^[^:]+@sha256:[0-9a-f]+$ ]] ; then
                echo "Failed to extract sha256 tag from ${image}. Exiting with failure"
                exit 1
            fi
            sha=$(echo "${image}" | cut -d ':' -f 2)
            # containerImage should be of the form registry.redhat.io/foo/bar@sha256:abcde
            # This value will be used as the basis for the example values that follow
            containerImage="${deliveryRepo}@sha256:${sha}"
            # Construct CVE json
            CVEsJson='{"cves":{"fixed":{}}}'
            CVES=$(jq -c '[.releaseNotes.cves[]? | select(.component=="'"$name"'")]' "${DATA_FILE}")
            NUM_CVES=$(jq 'length' <<< "$CVES")
            for ((j = 0; j < NUM_CVES; j++)); do
                cve=$(jq -c --argjson j "$j" '.[$j]' <<< "$CVES")
                cveJson=$(jq -n \
                    --arg id "$(jq -r '.key' <<< "$cve")" \
                    --argjson packages "$(jq -c '.packages // []' <<< "$cve")" \
                    '{($id): {"packages": $packages}}')
                CVEsJson=$(jq --argjson cve "$cveJson" '.cves.fixed += $cve' <<< "$CVEsJson")
            done
            # Add one entry per arch (amd64 for example)
            get-image-architectures "${image}" | while IFS= read -r arch_json;
            do
                arch=$(jq -r .platform.architecture <<< "${arch_json}")
                digest=$(jq -r .digest <<< "${arch_json}")
                containerImage="${deliveryRepo}@${digest}"
                # purl should be pkg:oci/bar@sha256%3Aabcde?arch=amd64&repository_url=registry.redhat.io/foo
                purl="pkg:oci/${deliveryRepo##*/}@${digest/:/%3A}?arch=${arch}&repository_url=${deliveryRepo%/*}"

                uniqueTag=""
                NUM_TAGS=$(jq length <<< "$tags")
                for ((j = 0; j < NUM_TAGS; j++)) ; do
                    tag=$(jq -r --argjson j "$j" '.[$j]' <<< "$tags")
                    if [[ $tag =~ $UNIQUE_TAG_REGEX ]] && [[ ${#tag} > ${#uniqueTag} ]] ; then
                        uniqueTag="${tag}"
                    fi
                done

                # if a unique tag is found, then purl will become:
                # pkg:oci/bar@sha256%3Aabcde?arch=amd64&repository_url=registry.redhat.io/foo&tag=0.1-12345678
                if [[ -n $uniqueTag ]] ; then
                    purl="${purl}&tag=${uniqueTag}"
                fi

                jsonString=$(jq -cn \
                    --arg component "$name" \
                    --arg arch "$arch" \
                    --arg containerImage "$containerImage" \
                    --arg purl "$purl" \
                    --arg repository "$deliveryRepo" \
                    --argjson tags "$tags" \
                    '{"architecture": $arch, "containerImage": $containerImage, "purl": $purl,
                    "repository": $repository, "tags": $tags, "component": $component}')
                if [ "$(jq '.cves.fixed | length' <<< "$CVEsJson")" -gt 0 ]; then
                    jsonString=$(jq --argjson cves "$CVEsJson" '. += $cves' <<< "$jsonString")
                fi

                # Inject JSON into data.json
                jq --argjson image "$jsonString" '.releaseNotes.content.images += [$image]' "${DATA_FILE}" > \
                    /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
            done
        done
    - name: populate-release-notes-binaries
      image: quay.io/konflux-ci/release-service-utils:ea7868ebdcc7a2116c620255034226611d837f42
      computeResources:
        limits:
          memory: 32Mi
        requests:
          memory: 32Mi
          cpu: 10m
      script: |
        #!/usr/bin/env bash
        set -ex

        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No data JSON was provided."
            exit 1
        fi

        # Try to extract the first contentType if it exists
        content_type=$(jq -r '.mapping.components[]?.contentGateway?.contentType // empty' "$DATA_FILE" | head -n1)

        if [ "$content_type" != "binary" ]; then
            echo "Not binary content. Skipping binary-specific logic."
            exit 0
        fi

        SNAPSHOT_FILE="$(params.dataDir)/$(params.snapshotPath)"
        if [ ! -f "${SNAPSHOT_FILE}" ] ; then
            echo "No valid snapshot file was provided."
            exit 1
        fi

        NUM_COMPONENTS=$(jq '.components | length' "${SNAPSHOT_FILE}")
        for ((i = 0; i < NUM_COMPONENTS; i++))
        do
            component=$(jq -c --argjson i "$i" '.components[$i]' "${SNAPSHOT_FILE}")
            name=$(jq -r '.name' <<< "$component")

            # Construct CVE json
            CVEsJson='{"cves":{"fixed":{}}}'
            CVES=$(jq -c '[.releaseNotes.cves[]? | select(.component=="'"$name"'")]' "${DATA_FILE}")
            NUM_CVES=$(jq 'length' <<< "$CVES")
            for ((j = 0; j < NUM_CVES; j++)); do
                cve=$(jq -c --argjson j "$j" '.[$j]' <<< "$CVES")
                cveJson=$(jq -n \
                    --arg id "$(jq -r '.key' <<< "$cve")" \
                    --argjson packages "$(jq -c '.packages // []' <<< "$cve")" \
                    '{($id): {"packages": $packages}}')
                CVEsJson=$(jq --argjson cve "$cveJson" '.cves.fixed += $cve' <<< "$CVEsJson")
            done

            # Get the number of files for this component
            FILES_LENGTH=$(jq --arg name "$name" \
              '[.mapping.components[]
                | select(.name == $name)
                | .files
                | length][0]' "$DATA_FILE")

            for ((k = 0; k < FILES_LENGTH; k++)); do
                file=$(jq -c --arg name "$name" --argjson k "$k" \
                    '.mapping.components[]
                      | select(.name == $name)
                      | .files[$k]' "$DATA_FILE")
                arch=$(jq -r '.arch' <<< "$file")
                os=$(jq -r '.os' <<< "$file")

                # This will be filled in with a later task after signing so we have an accurate checksum
                purl="placeholder"

                jsonString=$(jq -cn \
                  --arg component "$name" \
                  --arg arch "$arch" \
                  --arg os "$os" \
                  --arg purl "$purl" \
                  '{"architecture": $arch, "os": $os, "purl": $purl, "component": $component}')

                if [ "$(jq '.cves.fixed | length' <<< "$CVEsJson")" -gt 0 ]; then
                    jsonString=$(jq --argjson cves "$CVEsJson" '. += $cves' <<< "$jsonString")
                fi

                jq --argjson content "$jsonString" '.releaseNotes.content.artifacts += [$content]' "${DATA_FILE}" > \
                    /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
            done
        done
    - name: populate-release-notes-github
      image: quay.io/konflux-ci/release-service-utils:e85ceb962ee6f4d0672b4aa4e9946621ab302f20
      computeResources:
        limits:
          memory: 32Mi
        requests:
          memory: 32Mi
          cpu: 10m
      script: |
        #!/usr/bin/env bash
        set -ex

        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No data JSON was provided."
            exit 1
        fi

        # Extract github field from data.json
        github_field=$(jq -r '.github // empty' "$DATA_FILE")
        if [[ -z "$github_field" ]]; then
            echo "Not a github release. Skipping github-specific release note generation."
            exit 0
        fi

        SNAPSHOT_FILE="$(params.dataDir)/$(params.snapshotPath)"
        if [ ! -f "${SNAPSHOT_FILE}" ] ; then
            echo "No valid snapshot file was provided."
            exit 1
        fi

        # github releases are single-component snapshots
        # get component name from snapshot file
        name=$(jq -r '.components[0].name' "${SNAPSHOT_FILE}")
        # Construct CVE json
        CVEsJson='{"cves":{"fixed":{}}}'
        CVES=$(jq -c '[.releaseNotes.cves[]? | select(.component=="'"$name"'")]' "${DATA_FILE}")
        NUM_CVES=$(jq 'length' <<< "$CVES")
        for ((j = 0; j < NUM_CVES; j++)); do
            cve=$(jq -c --argjson j "$j" '.[$j]' <<< "$CVES")
            cveJson=$(jq -n \
                --arg id "$(jq -r '.key' <<< "$cve")" \
                --argjson packages "$(jq -c '.packages // []' <<< "$cve")" \
                '{($id): {"packages": $packages}}')
            CVEsJson=$(jq --argjson cve "$cveJson" '.cves.fixed += $cve' <<< "$CVEsJson")
        done

        GITHUB_RELEASE_VERSION="$(params.github_release_version)"
        GITHUB_RELEASE_URL="$(params.github_release_url)"

        # check that params datadir params binaries_dir exists
        if [ ! -d "$(params.dataDir)/$(params.binaries_dir)" ] ; then
            echo "Binaries directory does not exist."
            exit 1
        fi

        # get the checksum file from the binaries directory
        CHECKSUM_FILE=$(find "$(params.dataDir)/$(params.binaries_dir)" -name '*_SHA256SUMS')
        if [ ! -f "${CHECKSUM_FILE}" ] ; then
            echo "No checksum file was provided."
            exit 1
        fi

        # create a map of filename to checksum
        declare -A CHECKSUM_MAP

        while read -r checksum filename; do
          # Ignore empty lines and manifest file
          [[ -z "$filename" ]] && continue
          [[ "$filename" == *_manifest.json ]] && continue
          CHECKSUM_MAP["$filename"]="$checksum"
        done < "${CHECKSUM_FILE}"

        # Parse owner/repo from the release URL
        owner_repo=$(echo "$GITHUB_RELEASE_URL" | sed -E 's#https://github.com/([^/]+/[^/]+).*#\1#')

        # Get the number of files for this component
        FILES_LENGTH=$(jq --arg name "$name" \
          '[.mapping.components[]
            | select(.name == $name)
            | .files
            | length][0]' "$DATA_FILE")
        for ((k = 0; k < FILES_LENGTH; k++)); do
            file=$(jq -c --arg name "$name" --argjson k "$k" \
                '.mapping.components[]
                  | select(.name == $name)
                  | .files[$k]' "$DATA_FILE")
            file_source=$(jq -r '.source' <<< "$file")
            filename=$(basename "$file_source")
            arch=$(jq -r '.arch' <<< "$file")
            os=$(jq -r '.os' <<< "$file")
            # Ignore manifest files
            [[ "$filename" == *_manifest.json ]] && continue
            checksum="${CHECKSUM_MAP[$filename]}"
            download_url="https://github.com/$owner_repo/releases/download/$GITHUB_RELEASE_VERSION/$filename"
            purl="pkg:generic/$name@$GITHUB_RELEASE_VERSION?checksum=$checksum&download_url=$download_url"
            jsonString=$(jq -cn \
                --arg component "$name" \
                --arg arch "$arch" \
                --arg os "$os" \
                --arg purl "$purl" \
                '{"architecture": $arch, "os": $os, "purl": $purl, "component": $component}')
            if [ "$(jq '.cves.fixed | length' <<< "$CVEsJson")" -gt 0 ]; then
                jsonString=$(jq --argjson cves "$CVEsJson" '. += $cves' <<< "$jsonString")
            fi
            jq --argjson content "$jsonString" '.releaseNotes.content.artifacts += [$content]' "${DATA_FILE}" > \
                /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
        done
    - name: populate-release-notes-type-and-references
      image: quay.io/konflux-ci/release-service-utils:ea7868ebdcc7a2116c620255034226611d837f42
      computeResources:
        limits:
          memory: 32Mi
        requests:
          memory: 32Mi
          cpu: 10m
      script: |
        #!/usr/bin/env bash
        set -ex

        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No data JSON was provided."
            exit 1
        fi

        NUM_CVES=$(jq '.releaseNotes.cves | length' "${DATA_FILE}")

        # Set type to RHSA if there are fixed CVEs
        if [[ "$NUM_CVES" -gt 0 ]] ; then
            jq '.releaseNotes.type = "RHSA"' "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
        fi

        if [ "$(jq -r '.releaseNotes.type' "${DATA_FILE}")" != "RHSA" ] ; then
            echo "Type is not RHSA. Ensuring references key exists, but not adding any"
            jq '.releaseNotes.references += []' "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
            exit 0
        fi

        # Inject classification link into data.json references
        jq '.releaseNotes.references += ["https://access.redhat.com/security/updates/classification/"]' \
            "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"

        for ((i = 0; i < NUM_CVES; i++))
        do
            cve=$(jq -r --argjson i "$i" '.releaseNotes.cves[$i].key' "${DATA_FILE}")
            # Inject cve link into data.json references
            jq --arg cve "$cve" '.releaseNotes.references += ["https://access.redhat.com/security/cve/\($cve)"]' \
                "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
        done

        # Remove duplicate references
        jq '.releaseNotes.references |= unique' "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: "git"
        params:
          - name: url
            value: "$(params.taskGitUrl)"
          - name: revision
            value: "$(params.taskGitRevision)"
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
