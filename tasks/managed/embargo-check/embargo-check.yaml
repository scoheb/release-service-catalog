---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: embargo-check
  labels:
    app.kubernetes.io/version: "1.1.0"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: >
    Tekton task to check if any issues or CVEs in the releaseNotes key of the data.json
    are embargoed. It checks the issues by server using curl and checks the CVEs via an
    InternalRequest. If any issue does not exist or any CVE is embargoed, the task will
    fail. The task will also fail if a Jira issue listed is for a component that does
    not exist in the releaseNotes.content.images section or if said component does not
    list the CVE from the issue.
  params:
    - name: dataPath
      description: Path to the JSON string of the merged data to use in the data workspace
      type: string
    - name: requestTimeout
      type: string
      default: "180"
      description: InternalRequest timeout
    - name: pipelineRunUid
      type: string
      description: The uid of the current pipelineRun. Used as a label value when creating internal requests
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks to be used are stored
    - name: taskGitRevision
      type: string
      description: The revision in the taskGitUrl repo to be used
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored.
      type: string
      default: "empty"
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire.
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable.
      type: string
      default: ""
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: sourceDataArtifact
      type: string
      description: Location of trusted artifacts to be used to populate data directory
      default: ""
    - name: subdirectory
      description: Subdirectory inside the workspace to be used
      type: string
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: $(workspaces.data.path)
    - name: stepActionGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog stepActions to be used are stored
      default: https://github.com/konflux-ci/release-service-catalog.git
    - name: stepActionGitRevision
      type: string
      description: The revision in the stepActionGitUrl repo to be used
      default: production
  workspaces:
    - name: data
      description: The workspace where the snapshot spec json file resides
  results:
    - description: Produced trusted data artifact
      name: sourceDataArtifact
      type: string
  volumes:
    - name: workdir
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
      - name: "HOME"
        value: "/tekton/home"
  steps:
    - name: skip-trusted-artifact-operations
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.stepActionGitUrl)
          - name: revision
            value: $(params.stepActionGitRevision)
          - name: pathInRepo
            value: stepactions/skip-trusted-artifact-operations/skip-trusted-artifact-operations.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: subdirectory
          value: $(params.subdirectory)
        - name: dataDir
          value: $(params.dataDir)
    - name: use-trusted-artifact
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.stepActionGitUrl)
          - name: revision
            value: $(params.stepActionGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: dataDir
          value: $(params.dataDir)
        - name: subdirectory
          value: $(params.subdirectory)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: check-issues
      image: quay.io/konflux-ci/release-service-utils:0f82be4be43294b6a96846d87ef7f7c0b9e34267
      env:
        - name: ACCESS_TOKEN
          valueFrom:
            secretKeyRef:
              name: konflux-advisory-jira-secret
              key: token
      script: |
        #!/usr/bin/env bash

        SUPPORTED_ISSUE_TRACKERS='{
            "Jira": {
                "api": "rest/api/2/issue",
                "servers": [
                    "issues.redhat.com",
                    "jira.atlassian.com"
                ]
            },
            "bugzilla": {
                "api": "rest/bug",
                "servers": [
                    "bugzilla.redhat.com"
                ]
            }
        }'

        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No data JSON was provided."
            exit 1
        fi

        # It is expected for the custom field ids to remain stable, but to get them, you can do:
        # curl -H "Authorization: Bearer $ACCESS_TOKEN" https://issues.redhat.com/rest/api/2/field
        CVE_FIELD="customfield_12324749"
        COMPONENT_FIELD="customfield_12324752"

        RC=0

        NUM_ISSUES=$(jq -cr '.releaseNotes.issues.fixed | length' "${DATA_FILE}")
        for ((i = 0; i < NUM_ISSUES; i++)); do
            # We set +x before the curl call and then capture the exit code. That can lead to breaking out of the
            # current loop iteration or continuing on, so let's set -x at the beginning of each iteration
            set -x
            issue=$(jq -c --argjson i "$i" '.releaseNotes.issues.fixed[$i]' "${DATA_FILE}")
            server=$(jq -r '.source' <<< "$issue")
            API=$(jq -r '.[] | select(.servers[] | contains("'"$server"'")) | .api' <<< "$SUPPORTED_ISSUE_TRACKERS")
            API_URL="https://$(jq -r '.source' <<< "$issue")/${API}/$(jq -r '.id' <<< "$issue")"
            AUTH_ARGS=()
            set +x # We don't want to leak the ACCESS_TOKEN
            if [ "$server" = "issues.redhat.com" ] ; then
                AUTH_ARGS=(-H "Authorization: Bearer $ACCESS_TOKEN")
            fi
            OUTPUT=$(curl --retry 3 --fail "${AUTH_ARGS[@]}" "${API_URL}")
            if [ $? -ne 0 ] ; then
                echo "Error: ${issue} is not visible. Assuming it is embargoed and stopping pipelineRun execution."
                RC=1
                continue
            fi
            set -x

            # Perform additional checks only for issues on issues.redhat.com
            if [ "$server" != "issues.redhat.com" ] ; then
                continue
            fi

            # Public should be true if and only if the security field doesn't exist and the issue is accessible
            # without authentication
            public=false

            if ! "$(jq '.fields | has("security")' <<< "$OUTPUT")" ; then
                if curl -o /dev/null --retry 3 --fail "${API_URL}" ; then
                    public=true
                fi
            fi

            # Inject public key
            jq --argjson i "$i" --argjson public $public '.releaseNotes.issues.fixed[$i].public = $public' \
                "${DATA_FILE}" > /tmp/data.tmp && mv /tmp/data.tmp "${DATA_FILE}"

            # Perform cve specific checks only if the type is Vulnerability
            ISSUE_TYPE=$(jq -r '.fields.issuetype.name' <<< "$OUTPUT")
            if [ "$ISSUE_TYPE" != "Vulnerability" ] ; then
                continue
            fi

            CVE_ID=$(jq -r --arg field "$CVE_FIELD" '.fields[$field]' <<< "$OUTPUT")
            COMPONENT_NAME=$(jq -r --arg field "$COMPONENT_FIELD" '.fields[$field]' <<< "$OUTPUT")
            if ! COMPONENT_IN_RELEASE_NOTES="$(jq -ec --arg name "$COMPONENT_NAME" \
              '.releaseNotes.content.images[] | select(.component==$name)' "$DATA_FILE")"; then
                echo -n "Error: Issue $issue lists 'Downstream Component Name' $COMPONENT_NAME but that component does"
                echo " not appear in releaseNotes.content.images. Failing"
                RC=1
                continue
            fi

            if [ "$(jq --arg CVE "$CVE_ID" '.cves.fixed | has($CVE)' <<< "$COMPONENT_IN_RELEASE_NOTES")" != "true" ]
            then
                echo -n "Error: Issue $issue lists 'Downstream Component Name' $COMPONENT_NAME and 'CVE ID' $CVE_ID"
                echo " but that CVE is not present in the releaseNotes.content.images section for that component."
                RC=1
                continue
            fi
            
        done

        exit $RC
    - name: check-cves
      image: quay.io/konflux-ci/release-service-utils:0f82be4be43294b6a96846d87ef7f7c0b9e34267
      script: |
        #!/usr/bin/env bash

        DATA_FILE="$(params.dataDir)/$(params.dataPath)"
        if [ ! -f "${DATA_FILE}" ] ; then
            echo "No data JSON was provided."
            exit 1
        fi

        PIPELINERUN_LABEL="internal-services.appstudio.openshift.io/pipelinerun-uid"

        CVES=$(jq -r '.releaseNotes.content.images[].cves.fixed
            | to_entries[] | .key' "${DATA_FILE}" | sort -u | tr "\n" " ")

        if [[ ${CVES} == "" ]] ; then
            echo "No CVEs found to check"
            exit 0
        fi

        echo "Checking the following CVEs: ${CVES}"

        internal-request --pipeline "check-embargoed-cves" \
            -p cves="${CVES}" \
            -p taskGitUrl="$(params.taskGitUrl)" \
            -p taskGitRevision="$(params.taskGitRevision)" \
            -l ${PIPELINERUN_LABEL}="$(params.pipelineRunUid)" \
            -t "$(params.requestTimeout)" \
            -s true \
            > "$(params.dataDir)/$(params.subdirectory)/ir-result.txt" || \
            (grep "^\[" "$(params.dataDir)/$(params.subdirectory)ir-result.txt" | jq . && exit 1)

        internalRequest=$(awk -F"'" '/created/ { print $2 }' \
          "$(params.dataDir)/$(params.subdirectory)/ir-result.txt")
        echo "done (${internalRequest})"

        results=$(kubectl get internalrequest "$internalRequest" -o=jsonpath='{.status.results}')
        if [[ "$(echo "${results}" | jq -r '.result')" == "Success" ]]; then
          echo "No embargoed CVEs found"
        else
          echo "The following CVEs are marked as embargoed:"
          echo "${results}" | jq -cr '.embargoed_cves'
          exit 1
        fi
    - name: create-trusted-artifact
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.stepActionGitUrl)
          - name: revision
            value: $(params.stepActionGitRevision)
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: dataDir
          value: $(params.dataDir)
        - name: subdirectory
          value: $(params.subdirectory)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
    - name: patch-source-data-artifact-result
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.stepActionGitUrl)
          - name: revision
            value: $(params.stepActionGitRevision)
          - name: pathInRepo
            value: stepactions/patch-source-data-artifact-result/patch-source-data-artifact-result.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
