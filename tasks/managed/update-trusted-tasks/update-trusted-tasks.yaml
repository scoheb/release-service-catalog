---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: update-trusted-tasks
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: release
spec:
  description: |-
    Tekton task to update trusted-tasks list OCI artifact.
    Once a task is released as a bundle, the list of trusted-tasks should be 
    updated with the new task.
    The OCI artifact containing the trusted-tasks list is named `acceptable-data-bundles` and should reside in the same
    org in the registry. If it is already in place, it will be used as an input to which the results will be appended,
    else a new artifact will be created.
  params:
    - name: snapshotPath
      type: string
      description: Path to the JSON string of the Snapshot spec in the data workspace
    - name: ociStorage
      description: The OCI repository where the Trusted Artifacts are stored
      type: string
      default: "empty"
    - name: orasOptions
      description: oras options to pass to Trusted Artifacts calls
      type: string
      default: ""
    - name: ociArtifactExpiresAfter
      description: Expiration date for the trusted artifacts created in the
        OCI repository. An empty string means the artifacts do not expire
      type: string
      default: "1d"
    - name: trustedArtifactsDebug
      description: Flag to enable debug logging in trusted artifacts. Set to a non-empty string to enable
      type: string
      default: ""
    - name: dataDir
      description: The location where data will be stored
      type: string
      default: /var/workdir/release
    - name: sourceDataArtifact
      description: The source data artifact to use for trusted artifacts
      type: string
      default: ""
    - name: taskGitUrl
      type: string
      description: The url to the git repo where the release-service-catalog tasks and stepactions to be used are stored
    - name: taskGitRevision
      type: string
      description: The revision in the taskGitUrl repo to be used
  results:
    - name: sourceDataArtifact
      type: string
      description: Produced trusted data artifact
  volumes:
    - name: workdir
      emptyDir: {}
  stepTemplate:
    volumeMounts:
      - mountPath: /var/workdir
        name: workdir
    env:
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.ociArtifactExpiresAfter)
      - name: "ORAS_OPTIONS"
        value: "$(params.orasOptions)"
      - name: "DEBUG"
        value: "$(params.trustedArtifactsDebug)"
      # This is a workaround for a problem observed on a particular cluster where the
      # use-trusted-artifacts step runs with root user causing a docker credential file
      # to not be readable in later steps. There might be solution coming related to the
      # security context constraints on the cluster, but setting this explicitly here
      # should probably be harmless either way.
    securityContext:
      runAsUser: 1001
  steps:
    - name: use-trusted-artifact
      computeResources:
        limits:
          memory: 64Mi
        requests:
          memory: 64Mi
          cpu: 30m
      ref:
        resolver: "git"
        params:
          - name: url
            value: $(params.taskGitUrl)
          - name: revision
            value: $(params.taskGitRevision)
          - name: pathInRepo
            value: stepactions/use-trusted-artifact/use-trusted-artifact.yaml
      params:
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(params.sourceDataArtifact)
    - name: update-trusted-tasks
      image: quay.io/konflux-ci/appstudio-utils@sha256:591af845d7c700a178b3738e9725880e79cf63521a906325185bfe74d2a28407
      computeResources:
        limits:
          memory: 1Gi
        requests:
          memory: 1Gi
          cpu: 500m
      script: |
        #!/bin/bash
        set -eux
        
        SNAPSHOT_SPEC_FILE="$(params.dataDir)/$(params.snapshotPath)"
        TAG="latest"

        # check if snapshot exsits
        if [ ! -f "${SNAPSHOT_SPEC_FILE}" ] ; then
            echo "No valid snapshot file was found."
            exit 1
        fi

        # Extract the application from the snapshot
        application=$(jq -r '.application' "${SNAPSHOT_SPEC_FILE}")

        # Get the number of components
        NUM_COMPONENTS=$(jq '.components | length' "${SNAPSHOT_SPEC_FILE}")

        printf 'Beginning "%s" for "%s"\n\n' "$(context.task.name)" "$application"
        for ((i = 0; i < NUM_COMPONENTS; i++))
        do
            # extract the component from the snapshot 
            component=$(jq -c --argjson i "$i" '.components[$i]' "${SNAPSHOT_SPEC_FILE}")

            # Extract the repository from the snapshot
            repository=$(jq -r '.repository' <<< "$component")

            # The data-acceptable-bundles repo should reside in the same org in the registry.
            # Fetch the repository and replace the repo with data-acceptable-bundles
            # for example: quay.io/myorg/myrepo -> quay.io/myorg/data-acceptable-bundles
            ACCEPTABLE_BUNDLES=$(echo "${repository}" | awk -F'/' '{$NF="data-acceptable-bundles"; print $0}' OFS='/')

            # Extract the image sha
            sha=$(jq -r '.containerImage' <<< "$component" | awk -F'@' '{print "@" $2}')
            
            # Get the number of tags from the component
            NUM_TAGS=$(jq '.tags | length' <<< "$component")

            # update the tasks list OCI artifact for each tag in the component
            for ((j = 0; j < NUM_TAGS; j++))
            do
                imageTag=$(jq -c -r --argjson j "$j" '.tags[$j]' <<< "$component")
                
                set +e
                # Check if ACCEPTABLE_BUNDLES OCI artifact has a latest tag
                skopeo list-tags docker://"${ACCEPTABLE_BUNDLES}" | jq -r '.Tags[]' | grep "^${TAG}$" &> /dev/null
                RESULT=$?
                set -e

                # If it has a latest tag, use it as an --input for the ec track bundle command
                if [ $RESULT -eq 0 ]; then
                    echo "${ACCEPTABLE_BUNDLES}:${TAG} exists - using it as an input"
                    ec track bundle --bundle "${repository}:${imageTag}${sha}" \
                    --input oci:"${ACCEPTABLE_BUNDLES}:${TAG}" --output oci:"${ACCEPTABLE_BUNDLES}:${TAG}"

                # Else - Do not use it as an --input
                else
                    echo "${ACCEPTABLE_BUNDLES}:${TAG} does not exist"
                    ec track bundle --bundle "${repository}:${imageTag}${sha}" \
                    --output oci:"${ACCEPTABLE_BUNDLES}:${TAG}"
                fi        
            done
        done
    - name: create-trusted-artifact
      computeResources:
        limits:
          memory: 128Mi
        requests:
          memory: 128Mi
          cpu: 250m
      ref:
        resolver: "git"
        params:
          - name: url
            value: "$(params.taskGitUrl)"
          - name: revision
            value: "$(params.taskGitRevision)"
          - name: pathInRepo
            value: stepactions/create-trusted-artifact/create-trusted-artifact.yaml
      params:
        - name: ociStorage
          value: $(params.ociStorage)
        - name: workDir
          value: $(params.dataDir)
        - name: sourceDataArtifact
          value: $(results.sourceDataArtifact.path)
